.include "m16def.inc"

.dseg
_tmp_: .byte 2
.cseg

.def temp = r17
.def temp1 = r16
.def flag = r18
.def leds = r19
.def count = r21

.org 0x00
jmp start
.org 0x10
jmp ISR_TIMER1_OVF

start:
	ldi r24,LOW(RAMEND)																			; initialize stack
	out SPL,r24
	ldi r25,HIGH(RAMEND)
	out SPH,r25

	clr r24					
	out DDRA ,r24																				; PORTA as input (sensors)
	ldi r24, (1 << PD7) | (1 << PD6) | (1 << PD5) | (1 << PD4) | (1 << PD3) | (1 << PD2)		; set 6 MSBs as output (monitor)
	out DDRD, r24																				
	ser r24
	out DDRB ,r24																				; PORTB as output (alarm leds)

	ldi r24, (1 << PC7) | (1 << PC6) | (1 << PC5) | (1 << PC4)									; PORTD as output (keyboard)							
	out DDRC ,r24								

	call lcd_init																				; initialize LCD Monitor
	ldi flag,0xFF
	ldi count, 0																				; if flag == 0xFF password is incorrect (we start with this value)

sensor_loop:																					; we wait till one of the PORTA buttons is pressed 
	in temp,PINA																				; which driggers the alarm
	cpi temp,0x00
	breq sensor_loop

	ldi temp,(1<<TOIE1)																			; enable overflow interrupt of register TCNT1
	out TIMSK,temp																				; for timer1
	ldi temp,(1<<CS12) | (0<<CS11) | (1<<CS10)													; CK/1024 = 8MHz/1024 = 7812.5Hz
    out TCCR1B,temp																				; 7812.5 * 4sec = 31250 cycles
	ldi temp,0x85																				; MAX - 31250 = 65536 - 31250 = 34286 cycles = 0x85EE
	out TCNT1H,temp																				; we set TCNT1 to overflow after 4 seconds
	ldi temp,0xEE
	out TCNT1L,temp
	sei

	ldi r24,0x0f																				; we display cursor
	rcall lcd_command

password_loop:
	ldi r24, 20
	call scan_keypad_rising_edge							
	call keypad_to_ascii
	mov r20, r24
	cpi r20, 0
	breq password_loop
	cpi r20, 66																					; we check if 'B' is pressed
	brne password_incorrect
	call lcd_data
	inc count
first_digit_correct:
	ldi r24, 20
	call scan_keypad_rising_edge							
	call keypad_to_ascii
	mov r20, r24
	cpi r20, 0
	breq first_digit_correct
	cpi r20, 49																					; we check if '1' is pressed
	brne password_incorrect	
	call lcd_data
	inc count
second_digit_correct:
	ldi r24, 20
	call scan_keypad_rising_edge							
	call keypad_to_ascii
	mov r20, r24
	cpi r20, 0
	breq second_digit_correct
	cpi r20, 53																					; we check if '5' is pressed
	brne password_incorrect
	call lcd_data
	
	ldi flag,0x00																				; if yes flag is set accordingly

password_correct:
	ldi r24,0x0c																				; we remove cursor
	rcall lcd_command
	ldi r24, 0x02																				; return home
	rcall lcd_command
	ldi r24,'A'																					; display message for alarm off
	call lcd_data
	ldi r24,'L'
	call lcd_data
	ldi r24,'A'	
	call lcd_data
	ldi r24,'R'
	call lcd_data
	ldi r24,'M'
	call lcd_data
	ldi r24,' '
	call lcd_data
	ldi r24,'O'	
	call lcd_data
	ldi r24,'F'
	call lcd_data
	ldi r24,'F'
	call lcd_data
password_correct1:																				; and wait till timer is triggered
	jmp password_correct1

password_incorrect:																				; if password was incorrect we wait till 4 sec time ends
	call lcd_data
	inc count
inner_loop:
	cpi count, 3
	breq label0																				; while waiting user can write and see pressed digits
	ldi r24, 20
	call scan_keypad_rising_edge						
	call keypad_to_ascii
	cpi r24, 0
	breq inner_loop
	inc count
	call lcd_data
	jmp inner_loop

label0:
	ldi temp,(1<<TOIE1)																			; enable overflow interrupt of register TCNT1
	out TIMSK,temp																				; for timer1
	ldi temp,(1<<CS12) | (0<<CS11) | (1<<CS10)													; CK/1024 = 8MHz/1024 = 7812.5Hz
    out TCCR1B,temp																				; 7812.5 * 4sec = 31250 cycles
	ldi temp,0x00																				; MAX - 31250 = 65536 - 31250 = 34286 cycles = 0x85EE
	out TCNT1H,temp																				; we set TCNT1 to overflow after 4 seconds
	ldi temp,0x00
	out TCNT1L,temp	

ISR_TIMER1_OVF:
	ldi r24,low(200)						
	ldi r25,high(200)
	call wait_msec
	cpi flag,0x00																				; if 4 seconds pass we check if password was given correctly
	breq end_loop																				; if yes we skip all
	ldi r24,0x0c																				; we hide
	rcall lcd_command
	ldi r24, 0x02																				; return home
	rcall lcd_command
	ldi r24,'A'																					; display message for alarm on
	call lcd_data
	ldi r24,'L'
	call lcd_data
	ldi r24,'A'	
	call lcd_data
	ldi r24,'R'
	call lcd_data
	ldi r24,'M'
	call lcd_data
	ldi r24,' '
	call lcd_data
	ldi r24,'O'	
	call lcd_data
	ldi r24,'N'
	call lcd_data
leds_loop:																						; we set on the alarm
	ser leds
	out PORTB,leds																				; leds on for 0.2 sec
	ldi r24,low(200)						
	ldi r25,high(200)
	call wait_msec
	clr leds
	out PORTB,leds																				; leds off for 0.2 sec
	ldi r24,low(200)						
	ldi r25,high(200)
	call wait_msec
	jmp leds_loop
end_loop:
	reti


scan_row:
	ldi r25 ,0x08													; a?????p???s? µe ‘0000 1000’
back_: lsl r25														; a??ste?? ???s??s? t?? ‘1’ t?se? ??se??
	dec r24															; ?s?? e??a? ? a???µ?? t?? ??aµµ??
	brne back_
	out PORTC ,r25													; ? a?t?st???? ??aµµ? t??eta? st? ?????? ‘1’
	nop
	nop																; ?a??st???s? ??a ?a p????ße? ?a ???e? ? a??a?? ?at?stas??
	in r24 ,PINC													; ep?st??f??? ?? ??se?? (st??e?) t?? d?a??pt?? p?? e??a? p?esµ????
	andi r24 ,0x0f													; ap?µ??????ta? ta 4 LSB ?p?? ta ‘1’ de?????? p?? e??a? pat?µ????
	ret																; ?? d?a??pte?.


scan_keypad:
	ldi r24 ,0x01													; ??e??e t?? p??t? ??aµµ? t?? p???t????????
	rcall scan_row
	swap r24														; ap????e?se t? ap?t??esµa
	mov r27 ,r24													; sta 4 msb t?? r27
	ldi r24 ,0x02													; ??e??e t? de?te?? ??aµµ? t?? p???t????????
	rcall scan_row
	add r27 ,r24													; ap????e?se t? ap?t??esµa sta 4 lsb t?? r27
	ldi r24 ,0x03													; ??e??e t?? t??t? ??aµµ? t?? p???t????????
	rcall scan_row
	swap r24														; ap????e?se t? ap?t??esµa
	mov r26 ,r24													; sta 4 msb t?? r26
	ldi r24 ,0x04													; ??e??e t?? t?ta?t? ??aµµ? t?? p???t????????
	rcall scan_row
	add r26 ,r24													; ap????e?se t? ap?t??esµa sta 4 lsb t?? r26
	movw r24 ,r26													; µet?fe?e t? ap?t??esµa st??? ?ata????t?? r25:r24
	ret

scan_keypad_rising_edge:
	mov r22 ,r24													; ap????e?se t? ????? sp??????sµ?? st?? r22
	rcall scan_keypad												; ??e??e t? p???t??????? ??a p?esµ????? d?a??pte?
	push r24														; ?a? ap????e?se t? ap?t??esµa
	push r25
	mov r24 ,r22													; ?a??st???se r22 ms (t?p???? t?µ?? 10-20 msec p?? ?a?????eta? ap? t??
	ldi r25 ,0														; ?atas?e?ast? t?? p???t???????? – ?????d????e?a sp??????sµ??)
	rcall wait_msec
	rcall scan_keypad												; ??e??e t? p???t??????? ?a?? ?a? ap?????e
	pop r23															; ?sa p???t?a eµfa?????? sp??????sµ?
	pop r22
	and r24 ,r22
	and r25 ,r23
	ldi r26 ,low(_tmp_)												; f??t?se t?? ?at?stas? t?? d?a??pt?? st??
	ldi r27 ,high(_tmp_)											; p??????µe?? ???s? t?? ???t??a? st??? r27:r26
	ld r23 ,X+
	ld r22 ,X
	st X ,r24														; ap????e?se st? RAM t? ??a ?at?stas?
	st -X ,r25														; t?? d?a??pt??
	com r23
	com r22															; ß?e? t??? d?a??pte? p?? ????? «µ????» pat??e?
	and r24 ,r22
	and r25 ,r23
	ret

keypad_to_ascii:													; ?????? ‘1’ st?? ??se?? t?? ?ata????t? r26 d???????
	movw r26 ,r24													; ta pa?a??t? s?µß??a ?a? a???µ???
	ldi r24 ,'*'
	sbrc r26 ,0
	ret
	ldi r24 ,'0'
	sbrc r26 ,1
	ret
	ldi r24 ,'#'
	sbrc r26 ,2
	ret
	ldi r24 ,'D'
	sbrc r26 ,3														; a? de? e??a? ‘1’pa?a??µpte? t?? ret, a????? (a? e??a? ‘1’)
	ret																; ep?st??fe? µe t?? ?ata????t? r24 t?? ASCII t?µ? t?? D.
	ldi r24 ,'7'
	sbrc r26 ,4
	ret
	ldi r24 ,'8'
	sbrc r26 ,5
	ret
	ldi r24 ,'9'
	sbrc r26 ,6
	ret
	ldi r24 ,'C'
	sbrc r26 ,7
	ret
	ldi r24 ,'4'													; ?????? ‘1’ st?? ??se?? t?? ?ata????t? r27 d???????
	sbrc r27 ,0														; ta pa?a??t? s?µß??a ?a? a???µ???
	ret
	ldi r24 ,'5'
	sbrc r27 ,1
	ret
	ldi r24 ,'6'
	sbrc r27 ,2
	ret
	ldi r24 ,'B'
	sbrc r27 ,3
	ret
	ldi r24 ,'1'
	sbrc r27 ,4
	ret
	ldi r24 ,'2'
	sbrc r27 ,5
	ret
	ldi r24 ,'3'
	sbrc r27 ,6
	ret
	ldi r24 ,'A'
	sbrc r27 ,7
	ret
	clr r24
	ret

write_2_nibbles:
	push r24				; st???e? ta 4 MSB
	in r25 ,PIND			; d?aß????ta? ta 4 LSB ?a? ta ?a?ast?????µe
	andi r25 ,0x0f			; ??a ?a µ?? ?a??s??µe t?? ?p??a p??????µe?? ?at?stas?
	andi r24 ,0xf0			; ap?µ??????ta? ta 4 MSB ?a?
	add r24 ,r25			; s??d?????ta? µe ta p???p?????ta 4 LSB
	out PORTD ,r24			; ?a? d????ta? st?? ???d?
	sbi PORTD ,PD3			; d?µ?????e?ta? pa?µ?? Enable st?? a???d??t? PD3
	cbi PORTD ,PD3			; PD3=1 ?a? µet? PD3=0
	pop r24					; st???e? ta 4 LSB. ??a?t?ta? t? byte.
	swap r24				; e?a???ss??ta? ta 4 MSB µe ta 4 LSB
	andi r24 ,0xf0			; p?? µe t?? se??? t??? ap?st?????ta?
	add r24 ,r25
	out PORTD ,r24
	sbi PORTD ,PD3			; ???? pa?µ?? Enable
	cbi PORTD ,PD3
	ret


lcd_data:
	sbi PORTD ,PD2			; ep????? t?? ?ata????t? ded?µ???? (PD2=1)
	rcall write_2_nibbles	; ap?st??? t?? byte
	ldi r24 ,43				; a?aµ??? 43µsec µ???? ?a ?????????e? ? ????
	ldi r25 ,0				; t?? ded?µ???? ap? t?? e?e??t? t?? lcd
	rcall wait_usec
	ret


lcd_command:
	cbi PORTD ,PD2			; ep????? t?? ?ata????t? e?t???? (PD2=1)
	rcall write_2_nibbles	; ap?st??? t?? e?t???? ?a? a?aµ??? 39µsec
	ldi r24 ,39				; ??a t?? ????????s? t?? e?t??es?? t?? ap? t?? e?e??t? t?? lcd.
	ldi r25 ,0				; S??.: ?p?????? d?? e?t????, ?? clear display ?a? return home,
	rcall wait_usec			; p?? apa?t??? s?µa?t??? µe?a??te?? ??????? d??st?µa.
	ret


lcd_init:
	ldi r24 ,40				; ?ta? ? e?e??t?? t?? lcd t??f?d?te?ta? µe
	ldi r25 ,0				; ?e?µa e?te?e? t?? d??? t?? a?????p???s?.
	rcall wait_msec			; ??aµ??? 40 msec µ???? a?t? ?a ?????????e?.
	ldi r24 ,0x30			; e?t??? µet?ßas?? se 8 bit mode
	out PORTD ,r24			; epe?d? de? µp????µe ?a e?µaste ß?ßa???
	sbi PORTD ,PD3			; ??a t? d?aµ??f?s? e?s?d?? t?? e?e??t?
	cbi PORTD ,PD3			; t?? ??????, ? e?t??? ap?st???eta? d?? f????
	ldi r24 ,39
	ldi r25 ,0				; e?? ? e?e??t?? t?? ?????? ß??s?eta? se 8-bit mode
	rcall wait_usec			; de? ?a s?µße? t?p?ta, a??? a? ? e?e??t?? ??e? d?aµ??f?s?
							; e?s?d?? 4 bit ?a µetaße? se d?aµ??f?s? 8 bit
	ldi r24 ,0x30
	out PORTD ,r24
	sbi PORTD ,PD3
	cbi PORTD ,PD3
	ldi r24 ,39
	ldi r25 ,0
	rcall wait_usec
	ldi r24 ,0x20			; a??a?? se 4-bit mode
	out PORTD ,r24
	sbi PORTD ,PD3
	cbi PORTD ,PD3
	ldi r24 ,39
	ldi r25 ,0
	rcall wait_usec
	ldi r24 ,0x28			; ep????? ?a?a?t???? µe?????? 5x8 ?????d??
	rcall lcd_command		; ?a? eµf???s? d?? ??aµµ?? st?? ?????
	ldi r24 ,0x0c			; e?e???p???s? t?? ??????, ap?????? t?? ???s??a
	rcall lcd_command
	ldi r24 ,0x01			; ?a?a??sµ?? t?? ??????
	rcall lcd_command
	ldi r24 ,low(1530)
	ldi r25 ,high(1530)
	rcall wait_usec
	ldi r24 ,0x06			; e?e???p???s? a?t?µat?? a???s?? ?at? 1 t?? d?e????s??
	rcall lcd_command		; p?? e??a? ap????e?µ??? st?? µet??t? d?e????se?? ?a?
							; ape?e???p???s? t?? ???s??s?? ????????? t?? ??????
	ret


wait_usec:
   sbiw r24 ,1														; 2 ?????? (0.250 µsec)
   nop																; 1 ?????? (0.125 µsec)
   nop																; 1 ?????? (0.125 µsec)
   nop																; 1 ?????? (0.125 µsec)
   nop																; 1 ?????? (0.125 µsec)
   brne wait_usec													; 1 ? 2 ?????? (0.125 ? 0.250 µsec)
   ret																; 4 ?????? (0.500 µsec)


wait_msec:
   push r24															; 2 ?????? (0.250 µsec)
   push r25															; 2 ??????
   ldi r24 , low(998)												; f??t?se t?? ?ata?. r25:r24 µe 998 (1 ?????? - 0.125 µsec)
   ldi r25 , high(998)												; 1 ?????? (0.125 µsec)
   rcall wait_usec													; 3 ?????? (0.375 µsec), p???a?e? s??????? ?a??st???s? 998.375 µsec
   pop r25															; 2 ?????? (0.250 µsec)
   pop r24															; 2 ??????
   sbiw r24 , 1														; 2 ??????
   brne wait_msec													; 1 ? 2 ?????? (0.125 ? 0.250 µsec)
   ret																; 4 ?????? (0.500 µsec)

